{
    "collab_server" : "",
    "contents" : "#' Two-dimensional correlation analysis.\n#'\n#' \\code{corr2d} calculates the synchronous and asynchronous correlation\n#'     spectra between \\code{Mat1} and \\code{Mat1} (homo correlation)\n#'     or between \\code{Mat1} and \\code{Mat2} (hetero correlation).\n#'\n#' \\code{corr2d} uses a parallel fast Fourier transformation\n#'     (\\code{\\link[stats]{fft}}) to calculate the complex correlation matrix.\n#'     For parallelization the \\code{\\link[foreach]{foreach}} function is used.\n#'     Large input matrices (> 4000 columns) can lead to long calculation times\n#'     depending on the number of cores used. Also note that the resulting\n#'     matrix can become very large, adjust the RAM limit with\n#'     \\code{\\link[utils]{memory.limit}} accordingly. For a detailed description\n#'     of the underlying math see references.\n#'\n#' @param Mat1,Mat2 Numeric matrix containing the data which will be correlated;\n#'     '\\emph{Spectral variable}' by columns and '\\emph{perturbation}' by rows. For hetero\n#'     correlations \\code{Mat1} and \\code{Mat2} must have the same number of rows.\n#' @param Ref1,Ref2 Numeric vector containg a single spectrum, which will be\n#'     substracted from \\code{Mat1} (or \\code{Mat2}, respectivly) to generate dynamic spectra\n#'     for 2D correlation analysis. Defaults to \\code{NULL} in which case the \\code{colMeans()}\n#'     of \\code{Mat1} (or \\code{Mat2}, respectivly) is used as reference. The length of \\code{Ref1}\n#'     (or \\code{Ref2}) needs to be equal to the number of columns in \\code{Mat1} (or \\code{Mat2}).\n#' @param Wave1,Wave2 Numeric vector containing the spectral variable. Needs to be\n#'     specified if column names of \\code{Mat1} (or \\code{Mat2}) are undefinied.\n#' @param Time Numeric vector containing the perturbation. If specified, \\code{Mat1}\n#'     (and \\code{Mat2} if given) will be interpolated to \\code{N} equally spaced perturbation\n#'     values using \\code{Int} to speed up the fft algorithm.\n#' @param Int Function specifing how the dataset will be interpolated to give\n#'     \\code{N} equally spaced perturbation values.\n#' @param N Positive, non-zero integer specifing how many equally spaced\n#'     perturbation values should be interpolated using \\code{Int}. \\code{corr2d}\n#'     is fastest if \\code{N} is a power of 2.\n#' @param Norm Numeric vector specifing how the correlation matrix should be\n#'     normalized. Needs to have length \\code{(NCOL(Mat1) - 1)}.\n#' @param scaling Positive real number used as exponent when scaling the dataset\n#'     with its standard deviation. Defaults to 0 meaning no scaling. 0.5\n#'     (\\emph{Pareto scaling}) and 1 (\\emph{Pearson scaling}) are commonly used to enhance\n#'     weak correlations relative to strong correlations.\n#' @param corenumber Positive, non-zero integer specifing how many CPU cores\n#'     should be used for parallel fft computation.\n#' @param preview Logical scalar, should a 3D preview of the synchronous\n#'     correlation spectrum be drawn at the end? Uses \\code{\\link[rgl]{persp3d}} from \\pkg{rgl}\n#'     package.\n#'     \n#' @return \\code{corr2D} returns a list of class \"corr2d\" containing the complex\n#'     correlation matrix (\\code{$FT}), the used reference spectra (\\code{$Ref1},\n#'     \\code{$Ref2}), the spectral variables (\\code{$Wave1}, \\code{$Wave2}), the\n#'     (interpolated) perturbation (\\code{$Time}) and logical scalar (\\code{$Het})\n#'     indicating if homo (\\code{FALSE}) or hetero (\\code{TRUE}) correlation was done.\n#' \n#' @references \n#'     I. Noda, \\emph{Appl. Spectrosc.}, 1993, \\strong{47}, 1329-1336.\\cr\n#'     I. Noda, \\emph{Vib. Spectrosc.}, 2012, \\strong{60}, 146-153.\n#'     \n#' \n#' @seealso For plotting of the resulting list containing the 2D correlation\n#'     spectra see \\code{\\link{plot_corr2d}} and \\code{\\link{plot_corr2din3d}}.\n#' \n#' @examples\n#'     data(FuranMale, package = \"corr2D\")\n#'     twod <- corr2d(FuranMale, Ref1 = FuranMale[1, ], corenumber = 1)\n#'     \n#'     plot_corr2d(twod, xlab = expression(paste(\"relative Wavenumber\" / cm^-1)),\n#'                       ylab = expression(paste(\"relative Wavenumber\" / cm^-1)))\n#'\n#' @aliases corr2d\n#' \n#' @export\n#' @importFrom foreach %dopar%\n#' @importFrom stats fft sd\ncorr2d <-\n    function(Mat1, Mat2 = NULL, Ref1 = NULL, Ref2 = NULL,\n             Wave1 = NULL, Wave2 = NULL, Time = NULL, Int = stats::splinefun,\n             N = 2^ceiling(log2(NROW(Mat1))), Norm = 1/(pi * (NCOL(Mat1) - 1)), \n             scaling = 0, corenumber = parallel::detectCores(), preview = FALSE)\n    { \n        # create an R session for every detected CPU core for parallel computing\n        cl <- parallel::makeCluster(corenumber)\n        doParallel::registerDoParallel(cl)\n        \n        # spectral variable must be incresing, also switch Ref if needed ------\n        if (is.unsorted(as.numeric(colnames(Mat1)))) {\n            Mat1 <- Mat1[, NCOL(Mat1):1]\n            if (!is.null(Ref1)) {\n                Ref1 <- Ref1[length(Ref1):1]\n            }\n        }\n        if (!is.null(Mat2) && is.unsorted(as.numeric(colnames(Mat2)))) {\n            Mat2 <- Mat2[, NCOL(Mat2):1]\n            if (!is.null(Ref2)) {\n                Ref2 <- Ref2[length(Ref2):1]\n            }\n        }\n        \n        # define Wave1/2, D1/2, Het -------------------------------------------\n        if (is.null(Wave1)) {\n            Wave1 <- as.numeric(colnames(Mat1))\n        }\n        if (is.null(Mat2) || identical(Mat1, Mat2)) {\n            cat(c(\"HOMO-Correlation:\", corenumber, \"cores used for calculation\\n\"))\n            Het <- FALSE\n            D1 <- D2 <- dim(Mat1)\n            Wave2 <- Wave1\n            Mat2 <- Mat1\n            Ref2 <- Ref1\n        } else {\n            cat(c(\"HETERO-Correlation:\", corenumber, \"cores used for calculation\\n\"))\n            Het <- TRUE\n            D1 <- dim(Mat1)\n            D2 <- dim(Mat2)\n            if (is.null(Wave2)) {\n                Wave2 <- as.numeric(colnames(Mat2))\n            }\n        }\n        \n        # Interpolate values of perturbation variable for equidistant ---------\n        # datapoints for fft --------------------------------------------------\n        if ((is.null(Time) == FALSE) & (length(Time) == D1[1])) {\n            cat(c(format(Sys.time(), \"%X -\"), \"Interpolate Time from\",\n                  min(Time), \"to\", max(Time), \"\\n\", \"to obtain\", N,\n                  \"equidistant datapoints for FFT\", \"\\n\"))\n            MAT <- c()\n            TIME <- seq(min(Time), max(Time), length.out = N)\n            for (i in 1:NCOL(Mat1)) {\n                tmp <- Int(x = Time, y = Mat1[, i])\n                MAT <- cbind(MAT, tmp(TIME))\n            }\n            Mat1 <- MAT\n            if (Het == FALSE) {\n                Mat2 <- Mat1\n            } else {\n                MAT <- c()\n                for (i in 1:NCOL(Mat2)) {\n                    tmp <- Int(x = Time, y = Mat2[, i])\n                    MAT <- cbind(MAT, tmp(TIME))\n                }\n                Mat2 <- MAT\n            }\n        }\n        # Get perturbation variable from rownames\n        if (is.null(Time) == TRUE && is.null(rownames(Mat1)) == FALSE) {\n            Time <- as.numeric(rownames(Mat1))\n        } else {\n            Time <- NULL\n        }\n        \n        # Substract reference -------------------------------------------------\n        if (is.null(Ref1)) {\n            cat(c(format(Sys.time(), \"%X -\"), \"using mean values as reference\\n\"))\n            Ref1 <- colMeans(Mat1)\n            Ref2 <- colMeans(Mat2)\n        }\n        Mat1<-sweep(Mat1, 2, Ref1, \"-\")\n        if (Het == FALSE) {\n            Mat2 <- Mat1\n        } else {\n            Mat2 <- sweep(Mat2, 2, Ref2, \"-\")\n        }\n        \n        # Apply scaling -------------------------------------------------------\n        if (scaling > 0) {\n            cat(c(format(Sys.time(), \"%X -\"), \"apply scaling\\n\"))\n            sd1 <- apply(Mat1, 1, sd)\n            sd2 <- apply(Mat2, 1, sd)\n            Mat1 <- Mat1 / (sd1^scaling)\n            Mat2 <- Mat2 / (sd2^scaling)\n        }\n        \n        # Do fft for every wavenumber in both Mattices to obtain frequency ----\n        # dependent vectors for every wavenumber and scalar-multiply them -----\n        # for every point in the 2D-correlation spectrum ----------------------\n        FT <- NULL\n        cat(c(format(Sys.time(), \"%X -\"), \"Fast Fourier Transformation and Multiplication \\n\",\n              \"to obtain a\",D1[2], \"x\", D2[2], \"Correlation-Matrix\",\"\\n\"))\n        \n        FT <- matrix(NA, NCOL(Mat1), NCOL(Mat2))\n        ft1 <- foreach::foreach(i = 1:NCOL(Mat1), .combine = 'cbind') %dopar% {\n            fft(Mat1[, i])[1:NROW(Mat1) %/% 2]\n        }\n        if (Het == FALSE) {\n            ft2 <- ft1\n        } else {\n            ft2 <- foreach::foreach(i = 1:NCOL(Mat2), .combine = 'cbind') %dopar% {\n                fft(Mat2[, i])[1:NROW(Mat2) %/% 2]\n            }\n        }\n        \n        FT<-matrix(Norm * parallel::parCapply(cl, ft1, get(\"%*%\"), Conj(ft2)), NCOL(ft1), NCOL(ft2), byrow = T)\n        cat(c(format(Sys.time(), \"%X -\"), \"Done\\n\"))\n        \n        Obj<-list(FT = FT, Ref1 = Ref1, Ref2 = Ref2,\n                  Wave1 = Wave1, Wave2 = Wave2,\n                  Time = Time, Het = Het)\n        \n        parallel::stopCluster(cl)\n        #closeAllConnections()\n        \n        # 3d preview of the synchronous correlation spectrum ------------------\n        if (preview == TRUE) {\n            if (dim(FT)[1] > 700) {\n                tmp1 <- round(seq(1, dim(FT)[1], length = 700))\n            } else {\n                tmp1 <- seq(1, dim(FT)[1], 1)\n            }\n            if (dim(FT)[2] > 700) {\n                tmp2 <- round(seq(1, dim(FT)[2], length = 700))\n            } else {\n                tmp2 <- seq(1, dim(FT)[2], 1)\n            }\n            rgl::persp3d(Wave1[tmp1], Wave2[tmp2], Re(FT)[tmp1, tmp2], col = \"grey\")\n        }\n        \n        class(Obj) <- \"corr2d\"\n        return(Obj)\n    }\n\n#' @export\nsummary.corr2d <- function(object, ...)\n    {\n        cat(c(NROW(object$FT), \"x\", NCOL(object$FT), if (object$Het == TRUE){\"Hetero\"} else {\"Homo\"}, \"correlation spectra\\n\"))\n        if (object$Het == TRUE) {\n            cat(c(\"Spectral variable 1:\", min(object$Wave1), \"-\", max(object$Wave1), \"\\n\"))\n            cat(c(\"Spectral variable 2:\", min(object$Wave2), \"-\", max(object$Wave2), \"\\n\"))\n        } else {\n            cat(c(\"Spectral variable:\", min(object$Wave1), \"-\", max(object$Wave1), \"\\n\"))\n        }\n        if (!is.null(object$Time)) {\n            cat(c(\"Perturbation variable:\", length(object$Time), \"values,\", min(object$Time), \"-\", max(object$Time), \"\\n\"))\n        }\n    \n}\n\n#' Check for object class \"corr2d\"\n#'\n#' The function checks if an object is of class \"corr2d\".\n#' \n#' The function uses the \\code{\\link{inherits}} function.\n#' \n#' @param x An object which should be check if it is of class \"corr2d\".\n#' \n#' @return A logical scalar\n#'\n#' @examples \n#'     data(FuranMale, package = \"corr2D\")\n#'     twod <- corr2d(FuranMale, Ref1 = FuranMale[1, ], corenumber = 1)\n#'     \n#'     # TRUE\n#'     is.corr2d(twod) \n#'     # FALSE\n#'     is.corr2d(2) \n#'\n#' @export\nis.corr2d <- function(x)\n    {\n    inherits(x, \"corr2d\", which = FALSE)\n    }",
    "created" : 1460099483785.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3848306975",
    "id" : "AA7FB8C0",
    "lastKnownWriteTime" : 1464702148,
    "last_content_update" : 1464702148855,
    "path" : "C:/Users/ro63zic/Desktop/corr2d/R/corr2d.R",
    "project_path" : "R/corr2d.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}