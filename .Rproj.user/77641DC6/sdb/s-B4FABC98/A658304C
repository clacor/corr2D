{
    "collab_server" : "",
    "contents" : "#' Plot two-dimensional correlation spectra.\n#'\n#' \\code{plot_corr2d} plots two-dimensional correlation spectra either\n#'     as an image or a contour plot. Red colour indicates positive\n#'     correlations, while blue colour shows negative ones.\n#'\n#' For the synchronous correlation spectrum the real component (\\code{Re})\n#'     of the complex correlation matrix must be plotted. The asynchronous\n#'     spectrum is the respective imaginary component (\\code{Im}).\n#'     \\code{Cutout} can be used to leave out smaller (noise) contributions,\n#'     but should be used with care as it can be used to create misleading\n#'     2D correlation plots. See references for interpretation rules (so\n#'     called Noda rules).\n#' \n#' @param Obj List from \\code{corr2d} containing the\n#'     2D correlation data.\n#' @param what Real numeric matrix containg the z-values that should be plotted.\n#' @param specx,specy Numeric vector containing the data that should be plotted\n#'     on top (\\code{specx}) and/or on the left (\\code{specy}) of\n#'     the 2D spectrum. \\code{Mat}, \\code{specx} and/or \\code{specy} should\n#'     have the same dimensions, respectivly. If \\code{NULL} nothing will\n#'     be plotted.\n#' @param xlim,ylim Numeric vector with two values indicating the borders\n#'     of the 2D plot. Also truncates \\code{specx} and/or \\code{specy} to\n#'     match the new plot range.\n#' @param xlab,ylab Charakter or expression containing the text that will\n#'     be plotted on the bottom (\\code{xlab}) and/or to the left\n#'     (\\code{ylab}) of the 2D plot. Labels can be suppressed with \\code{NA}.\n#' @param Contour Logical scalar. Should a contour (\\code{TRUE}) or image\n#'     (\\code{FALSE}) be drawn?\n#' @param axes Integrer ranging from 0 to 3. Should the axis of the 2D plot\n#'     be drawn? \"0\" means no axes, \"1\" only bottom axis, \"2\" only left axis and\n#'     \"3\" both axes are drawn.\n#' @param Legend Logical scalar. Should a colour legend be plotted in the top\n#'     right corner?\n#' @param N Positive, non-zero integrer indicating how many contour or image\n#'     levels should be plotted.\n#' @param zlim Numeric vector with two values defining the z-range of the 2D\n#'     plot.\n#' @param Cutout Numeric vector with two values defining which z-values should\n#'     not be plotted. Use with care, because this can generate misleading\n#'     2D plots. \n#' @param ... Additional arguments either passed to\n#'     \\code{\\link[graphics]{image}} or \\code{\\link[graphics]{contour}}\n#'\n#' @references I. Noda, \\emph{J. Mol. Struct.}, 2006, \\strong{799}, 41-47.\n#' \n#' @seealso See \\code{\\link{plot_corr2din3d}} for 3D plots.\n#'\n#' @aliases plot_corr2d\n#' \n#' @examples\n#'     data(FuranMale, package = \"corr2D\")\n#'     twod <- corr2d(FuranMale, Ref1 = FuranMale[1, ], corenumber = 1)\n#'     \n#'     plot_corr2d(twod, xlab = expression(paste(\"relative Wavenumber\" / cm^-1)),\n#'                       ylab = expression(paste(\"relative Wavenumber\" / cm^-1)))\n#'\n#' @export\n#' @importFrom grDevices rgb\n#' @importFrom graphics abline axis box close.screen mtext par plot.default screen split.screen\n#' @importFrom stats quantile\nplot_corr2d <-\n    function(Obj, what = Re(Obj$FT), specx = Obj$Ref1, specy = Obj$Ref2,\n             xlim = NULL, ylim = NULL,\n             xlab = expression(nu[1]), ylab = expression(nu[2]),\n             Contour = TRUE, axes = 3, Legend = TRUE, N = 20,\n             zlim = NULL, Cutout = NULL, ...)\n    {\n        par_old <- par(no.readonly = TRUE)\n        # avoid \"invalid screen(1)\" error in RStudio --------------------------\n        close.screen(all.screens = T)\n        graphics::plot.new()\n        \n        # calculate x- and y-window range -------------------------------------\n        if (is.null(xlim)) {\n            Which1 <- 1:NROW(what)\n        } else {\n            Which1 <- which(xlim[1] < Obj$Wave1 & Obj$Wave1 < xlim[2])\n        }\n        \n        if (is.null(ylim)) {\n            Which2 <- 1:NCOL(what)\n        } else {\n            Which2 <- which(ylim[1] < Obj$Wave2 & Obj$Wave2 < ylim[2])\n        }\n        \n        # create splitscreen for plotting -------------------------------------\n        OFF <- 0.05\n        split.screen(rbind(c(0, 0.15 + OFF, 0.15 + OFF, 0.85 - OFF),          # Spectrum left\n                           c(0.15 + OFF, 0.85 - OFF, 0.85 - OFF, 1),          # Spectrum top\n                           c(0.15 + OFF, 0.85 - OFF, 0.15 + OFF, 0.85 - OFF), # Main\n                           c(0.85 - OFF, 1, 0.15 + OFF, 0.85 - OFF),          # right\n                           c(0.15 + OFF, 0.85 - OFF, 0, 0.15 + OFF),          # bottom\n                           c(0, 0.15 + OFF, 0.85 - OFF, 1),                   # top left\n                           c(0.85 - OFF, 1, 0.85 - OFF, 1)                    # Legend top right\n        )\n        )\n        \n        # plot one dimensional spectra top and left ---------------------------\n        if (!is.null(specy)) {\n            # Spec left ------------------------------------------------------\n            screen(1)\n            par(xaxt = \"n\", yaxt=\"n\", mar=c(0, 0, 0, 0), bty=\"n\", yaxs=\"i\")\n            plot.default(x = max(specy[Which2]) - specy[Which2],\n                         y = 1:length(specy[Which2]),\n                         type = \"l\", lwd = par()$lwd + 1, ann = F)\n        }\n        \n        if (!is.null(specx)) {\n            # Spec top -------------------------------------------------------\n            screen(2)\n            par(xaxt = \"n\", yaxt = \"n\", mar = c(0, 0, 0, 0), bty = \"n\", xaxs = \"i\")\n            plot.default(1:length(specx[Which1]), specx[Which1],\n                         type = \"l\", lwd = par()$lwd + 1, ann = F)\n        }\n        \n        # main Part -----------------------------------------------------------\n        screen(3)\n        if (is.null(zlim)) {\n            zlim <- range(what[Which1, Which2])\n        }\n        # Number of levels is always odd --------------------------------------\n        if (N%%2 == 0){\n            N <- N + 1\n        }\n        # Symmetric distribution of color code --------------------------------\n        Where <- seq(-max(abs(zlim)), max(abs(zlim)), length.out = N) \n        \n        if (is.null(Cutout)) {\n            OM <- which(Where < 0)\n            OP <- which(Where > 0)\n        } else {\n            OM <- which(Where <= Cutout[1])\n            OP <- which(Where >= Cutout[2])\n        }\n        \n        COL <- rep(\"transparent\", length(Where))\n        COL[OM] <- fields::designer.colors(col = c(\"darkblue\", \"cyan\"), n = length(OM))\n        COL[OP] <- fields::designer.colors(col = c(\"yellow\", \"red\", \"darkred\"), n = length(OP))\n        COL[(N + 1)/2] <- \"transparent\"\n        COL <- COL[which(zlim[1] < Where & Where < zlim[2])]\n        Where <- seq(zlim[1], zlim[2], length.out = length(COL))\n        \n        par(xaxt = \"n\", yaxt = \"n\", mar = c(0, 0, 0, 0), bty = \"n\", xaxs = \"i\", yaxs = \"i\")\n        if (Contour == TRUE){\n            graphics::contour(x = Obj$Wave1[Which1], y = Obj$Wave2[Which2], z = what[Which1, Which2],\n                              col = COL, levels = Where, zlim = zlim, drawlabels = F, ...)\n        } else {\n            graphics::image(x = Obj$Wave1[Which1], y = Obj$Wave2[Which2], z = what[Which1, Which2],\n                                col = COL, xlab = \"\", ylab = \"\", zlim = zlim, ...)\n        }\n\n        abline(a = 0, b = 1, col = rgb(red = 1, green = 1, blue = 1, alpha = 0.5), lwd = par()$lwd * 2)\n        par(xpd = NA, xaxt = \"s\", yaxt = \"s\", xaxs = \"i\", yaxs = \"i\", cex = 1, mar=c(0, 0, 0, 0))\n        box(which = \"figure\", lwd = 1)\n        if ((axes == 1) | (axes == 3)){\n            axis(side = 1, lwd = 1)\n        }\n        if ((axes == 2) | (axes == 3)){\n            axis(side = 4, las = 2, lwd = 1)\n        }\n\n        mtext(side = 1, xlab, line = 3.5, cex = par()$cex ++ 0.3)\n        mtext(side = 4, ylab, line = 3.5, cex = par()$cex ++ 0.3)\n\n        if(Legend == TRUE){\n            # top right -------------------------------------------------------\n            screen(7)\n            # avoid par(par.old) error from image.plot() by setting par(pin) value positive\n            par(pin = abs(par()$pin))\n            if (Contour == TRUE){\n                fields::image.plot(z = what[Which1,Which2], legend.only = T,\n                                   smallplot = c(0.15, 0.3, 0.2, 0.8), col = COL,\n                                   axis.args = list(at = quantile(Where, prob = c(0.1, 0.9)),\n                                   labels = format(x = quantile(Where, prob = c(0.1, 0.9)), digit = 2)),\n                                   zlim = zlim, legend.lab = \"\", cex = 0.7)\n            } else {\n                fields::image.plot(z = what[Which1, Which2],legend.only = T,\n                                   smallplot = c(0.15, 0.3, 0.2, 0.8),\n                                   col = COL, axis.args = list(at = range(what[Which1, Which2]),\n                                   labels = format(x = range(what[Which1, Which2]), digits = 2)),\n                                   legend.lab = \"\", cex = 0.7)\n            }\n            \n        }\n        \n        screen(3, new = F)\n        close.screen(c(1,2,4,5,6,7))\n        on.exit(options(par_old), add = TRUE)\n    }\n\n#' 3D plot of two-dimensional correlation spectra.\n#'\n#' \\code{plot_corr2din3d} plots two-dimensional correlation spectra as an 3D surface.\n#'\n#' For the synchronous correlation spectrum the real component (\\code{Re})\n#'     of the complex correlation matrix must be plotted. The asynchronous\n#'     spectrum is the respective imaginary component (\\code{Im}).\n#' \n#' @param Mat Real numeric matrix containing the z-values to plot.\n#' @param specx,specy Numeric vector containg the data, that will be\n#'     plotted at the x and y axis. Can be any data and does not need to have\n#'     the same dimensions as \\code{Mat}.\n#' @param scalex,scaley A real number which describes how \\code{specx}\n#'     (or \\code{specy}) get scaled. Positive numbers lead to a spectrum\n#'     plotted inside the box, while negative numbers lead to a spectrum\n#'     plotted outside the box.\n#' @param Col Vector containg colours used to plot the 3D plot and the\n#'     respective projection. \n#' @param reduce Non-zero rational number describing how to\n#'     \\code{\\link[mmand]{resample}} the data values. Can reduce the \n#'     computational demand and can be used for fast previews.\n#' @param zlim Numeric vector with two values indicating the z-range of\n#'     the 3D plot.\n#' @param projection Logical scalar. Should a 2D projection of the 3D surface\n#'     be plotted a the bottom of the box?\n#' @param ... Additional arguments passed to \\code{\\link[fields]{drape.plot}}\n#' \n#' @seealso See \\code{\\link{plot_corr2d}} for 2D plots.\n#'     See \\code{\\link[fields]{drape.plot}} for information on the plot function.\n#' \n#' @aliases plot_corr2din3d\n#' \n#' @examples\n#'    data(FuranMale, package = \"corr2D\")\n#'    twod <- corr2d(FuranMale, Ref1 = FuranMale[1, ], corenumber = 1)\n#'    \n#'    plot_corr2din3d(Mat = Re(twod$FT), specx = twod$Ref1,\n#'        specy = twod$Ref1, reduce = 2, scalex = -175, scaley = -175,\n#'        zlim = c(-0.75, 1.25)*10^-4, projection = FALSE,\n#'        border = NA, theta = 25, phi = 15, add.legend = FALSE)\n#'    \n#' @export\n#' @importFrom graphics par polygon lines\n#' @importFrom stats median\nplot_corr2din3d <-\n    function(Mat, specx = NULL, specy = NULL,\n             scalex = NULL, scaley = NULL, Col = NULL, reduce = NULL,\n             zlim = NULL, projection = FALSE, ...)\n    {\n        par_old <- par(no.readonly = TRUE)\n        x <- 1:NROW(Mat)\n        y <- 1:NCOL(Mat)\n\n        if (!is.null(reduce)) {\n            Which.x <- (1:length(x))[which(1:length(x)%%reduce == 0)]\n            Which.y <- (1:length(y))[which(1:length(y)%%reduce == 0)]\n            Mat <- mmand::resample(x = Mat, points = list(x = x[Which.x],\n                                   y = y[Which.y]), kernel = mmand::boxKernel())\n            x <- x[Which.x]\n            y <- y[Which.y]\n        }\n        if (is.null(Col)){\n            Zero <- median(Mat)\n            Max <- max(Mat)\n            Min <- min(Mat)\n            Breaks <- c(seq(from = Min, to = Zero, length.out = 33),\n                        seq(from = Zero, to = Max, length.out = 33)[2:33])\n            Col <- fields::tim.colors(64)\n        }else{\n            Breaks <- NULL\n        }\n        if (is.null(zlim)){\n            zlim <- range(Mat, na.rm = T)\n        }\n        \n        if (projection == TRUE){\n            WW <- fields::drape.plot(x = x, y = y, z = Mat, col = Col, breaks = Breaks, zlim = zlim, ...)\n            COL <- fields::drape.color(z = Mat, col = Col, zlim = zlim, breaks = Breaks)$color.index\n            for (i in 2:NROW(Mat)) {\n                for (j in 2:NCOL(Mat)) {\n                    Points <- grDevices::trans3d(y = y[c(j - 1, j, j, j - 1, j - 1)],\n                                                 x = x[c(i - 1, i - 1, i, i, i - 1)],\n                                                 z = rep(zlim[1], length(5)), pmat = WW)\n                    polygon(Points$x, Points$y,\n                            border = NA, col = COL[i - 1, j - 1])\n                }\n            }\n            par(new=T)\n            fields::drape.plot(x = x, y = y, z = Mat, col = Col, breaks = Breaks, zlim = zlim, ...)\n        } else {\n            WW <- fields::drape.plot(x = x, y = y, z = Mat, col = Col, breaks = Breaks, zlim = zlim, ...)\n        }\n        \n        \n        \n        if (!is.null(specx)) {\n            if (is.null(scalex)) {\n                scalex <- 1\n            }\n            X<-seq(min(x), max(x), length.out = length(specx))\n            Points.x <- grDevices::trans3d(x = X, y = min(y) + scalex * specx,\n                                           z = rep(zlim[1], length(X)), pmat = WW)\n            lines(x = Points.x$x, Points.x$y, lwd = 2)\n        }\n        \n        if (!is.null(specy)) {\n            if (is.null(scaley)) {\n                scaley <- 1\n            }\n            Y<-seq(min(y), max(y), length.out = length(specy))\n            Points.y <- grDevices::trans3d(y = Y, x = max(x) - scaley * specy,\n                                           z = rep(zlim[1], length(Y)), pmat = WW)\n            lines(x = Points.y$x, Points.y$y, lwd = 2)\n        }\n        \n        on.exit(options(par_old), add = TRUE)\n    }\n\n#' @export\n#' \n#' @seealso See \\code{\\link{plot_corr2d}}\nplot.corr2d <- function(x, ...)\n{\n    plot_corr2d(x, ...)\n}",
    "created" : 1460099479550.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "681226819",
    "id" : "A658304C",
    "lastKnownWriteTime" : 1464704624,
    "last_content_update" : 1464704624834,
    "path" : "C:/Users/ro63zic/Desktop/corr2d/R/corr2d_plot.R",
    "project_path" : "R/corr2d_plot.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}